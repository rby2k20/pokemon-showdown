"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const latest = require("./latest.json");
const LATEST = latest;
const GENS = ['rb', 'gs', 'rs', 'dp', 'bw', 'xy', 'sm', 'ss'];
function toID(text) {
    return ('' + text).toLowerCase().replace(/[^a-z0-9]+/g, '');
}
exports.Analyses = new (class {
    constructor() {
        this.URL = 'https://www.smogon.com/dex/';
    }
    /**
     * Returns the Analysis URL for a given pokemon and generation.
     */
    url(pokemon, gen = 8) {
        return `${exports.Analyses.URL}${exports.Analyses.gen(gen)}/pokemon/${toID(pokemon)}/`;
    }
    /**
     * Parses out the DexSettings object embedded in the raw HTML retrieved from the Smogon dex.
     */
    parse(raw) {
        const match = raw.match(/dexSettings = ({.*})/);
        if (!match)
            return undefined;
        return JSON.parse(match[1]);
    }
    /**
     * Given either the raw HTML retrieved from the Smogon dex or the parsed DexSettings object,
     * returns a map of Analysis objects keyed by format or undefined if its input was invalid.
     */
    process(ds) {
        const parsed = typeof ds === 'string' ? exports.Analyses.parse(ds) : ds;
        const valid = parsed &&
            parsed['injectRpcs'] &&
            parsed['injectRpcs'][2] &&
            parsed['injectRpcs'][2][1] &&
            parsed['injectRpcs'][2][1]['strategies'];
        if (!valid)
            return undefined;
        const analysesByFormat = new Map();
        for (const analysis of parsed['injectRpcs'][2][1]['strategies']) {
            let analyses = analysesByFormat.get(analysis.format);
            if (!analyses) {
                analyses = [];
                analysesByFormat.set(analysis.format, analyses);
            }
            analyses.push(analysis);
        }
        return analysesByFormat;
    }
    /**
     * Returns Smogon's display representation of the given gen.
     */
    gen(gen) {
        return GENS[gen - 1];
    }
})();
// Metagames which continued to be played after gen6, transitioning from a bare unqualified
// name to a 'gen6'-qualified one. Most migrated over on 2017-07, though the LATE metagames
// below were only given qualification from 2018 and onward.
// prettier-ignore
const LEGACY = new Set([
    '1v1', 'anythinggoes', 'battlespotdoubles', 'battlespotsingles', 'battlespottriples',
    'cap', 'lc', 'monotype', 'nu', 'ou', 'pu', 'randombattle', 'ru', 'ubers', 'uu',
    'balancedhackmons', 'doublesou', 'doublesuu', 'battlefactory', 'mixandmega', 'vgc2016',
    'ounoteampreview', 'customgame', 'doublescustomgame', 'triplescustomgame',
]);
exports.Statistics = new (class {
    constructor() {
        this.URL = 'https://www.smogon.com/stats/';
    }
    /**
     * Given the HTML page returned from querying the Statistics.URL, returns the most recent
     * date stats are available for. This should usually be the beginning of the current month,
     * but this approach is more robust due to timezone differences and delays in publishing.
     */
    latest(page) {
        const lines = page.split('\n');
        let i = lines.length;
        while (i--) {
            const line = lines[i];
            if (line.startsWith('<a href=')) {
                return line.slice(9, 16);
            }
        }
        throw new Error('Unexpected format for index');
    }
    /**
     * Returns the URL of the detailed ('chaos') stats for the given date and format, defaulting
     * to providing the highest weighted stats available for the format in question. Unweighted
     * stats or stats of a specific weight may also be requested, though may be absent depending
     * on the date and format.
     */
    url(date, format, weighted = true) {
        let formatid = toID(format);
        // When Gen 7 was released the naming scheme for 'current' formats was changed from
        // 'x' => 'genNx'. formatFor will translate between the two as approriate, but there
        // is an edge case for 2016-12 where both randombattle and gen6randombattle exist
        if (!(date === '2016-12' && ['gen6randombattle', 'randombattle'].includes(formatid))) {
            formatid = formatFor(formatid, date);
        }
        // If we've been given a weight then we use that, otherwise we use weightFor to
        // figure out what the highest weight cutoff for the format was (usually 1760 or 1825)
        // prettier-ignore
        const rating = weighted
            ? typeof weighted === 'number' ? weighted
                : weightFor(formatid, date)
            : 0;
        return `${exports.Statistics.URL}${date}/chaos/${formatid}-${rating}.json`;
    }
    /**
     * Returns the date and count of the latest stats available for the given format at the time
     * this package was published. If best is provided, it will return the date and count for the
     * most recent month where a substantial enough amount of data was gathered. Returns undefined
     * if there is no data present. Note the accuracy of this function depends on the data in
     * latest.json being kept up to date.
     */
    latestDate(format, best = false) {
        format = exports.Statistics.canonicalize(toID(format));
        const data = LATEST[format];
        if (!data)
            return undefined;
        const [date, count] = (Array.isArray(data[0]) ? data[+best] : data);
        return { date, count };
    }
    /**
     * Returns the canconical format name for the given format.
     */
    canonicalize(format) {
        return LEGACY.has(format) ? `gen6${format}` : format;
    }
    /**
     * Processes what was fetched from the URL returned by Statistics.url into UsageStatistics.
     */
    process(raw) {
        return JSON.parse(raw);
    }
})();
// prettier-ignore
const POPULAR = [
    'gen8ou', 'gen8doublesou', 'gen7ou', 'gen7doublesou',
    'ou', 'doublesou', 'smogondoubles', 'randombattle',
];
function weightFor(format, date) {
    // gen7doublesu ou and smogondoublessuspecttest have used different weights over the years
    if (format === 'gen7doublesou' && date < '2017-02')
        return 1760;
    if (format === 'smogondoublessuspecttest' && date === '2015-04')
        return 1825;
    // Otherwise, formats deemed 'popular' are assigned higher weight. Note that legacy format
    // notation is signficant here: gen6ou was only 'popular' while it was still called 'ou'
    return POPULAR.includes(format) ? 1825 : 1760;
}
const LATE = ['1v1', 'cap', 'monotype', 'balancedhackmons', 'mixandmega'];
function formatFor(format, date) {
    // 2017-01/02 mark the last random battle statistics, at which point randombattle has been
    // renamed to its qualified form several months before the other formats
    if (['gen6randombattle', 'randombattle'].includes(format) && date > '2016-12') {
        return 'gen6randombattle';
    }
    const m = format.match(/gen(\d)(.*)/);
    // Return if we've been given a format with the standard notation and its not Gen 6
    if (m && m[1] !== '6')
        return format;
    // Return the unqualified metagame if the format starts with 'gen6' but has been discontinued
    if (m && !LEGACY.has(m[2]))
        return m[2];
    if (m) {
        // If the format is 'gen6'-qualified but the date requested is before the standard 2017-06/07
        // migration (or was a late-migrating metagame and before 2017-12/2018-01), remove the qualifier
        return date < '2017-07' || (date < '2018-01' && LATE.includes(m[2])) ? m[2] : format;
    }
    else {
        // If the format unqualified but the date requested is after the standard 2017-06/07 migration
        // (or was a late-migrating metagame and after 2017-12/2018-01), add the 'gen6'-qualifier
        return date > '2017-12' || (date > '2017-06' && LATE.includes(format))
            ? `gen6${format}`
            : format;
    }
}
//# sourceMappingURL=index.js.map